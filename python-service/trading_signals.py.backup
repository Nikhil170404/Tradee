"""
Advanced Trading Signals System
Combines Technical, Fundamental, and Sentiment Analysis
"""

import yfinance as yf
import pandas as pd
import numpy as np
from typing import Dict, List
from datetime import datetime, timedelta


def calculate_rsi(prices: pd.Series, period: int = 14) -> float:
    """Calculate RSI indicator"""
    delta = prices.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()

    if loss.iloc[-1] == 0:
        return 100

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return float(rsi.iloc[-1])


def calculate_atr(df: pd.DataFrame, period: int = 14) -> float:
    """Calculate Average True Range for volatility measurement"""
    if len(df) < period:
        return 1.0  # Default fallback for insufficient data

    high = df['High']
    low = df['Low']
    close = df['Close']

    tr1 = high - low
    tr2 = abs(high - close.shift())
    tr3 = abs(low - close.shift())

    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = tr.rolling(window=period).mean()

    if pd.isna(atr.iloc[-1]):
        return 1.0  # Fallback if calculation fails

    return float(atr.iloc[-1])


def calculate_macd(prices: pd.Series) -> Dict:
    """Calculate MACD indicator"""
    exp1 = prices.ewm(span=12, adjust=False).mean()
    exp2 = prices.ewm(span=26, adjust=False).mean()
    macd = exp1 - exp2
    signal = macd.ewm(span=9, adjust=False).mean()
    histogram = macd - signal

    return {
        "macd": float(macd.iloc[-1]),
        "signal": float(signal.iloc[-1]),
        "histogram": float(histogram.iloc[-1])
    }


def calculate_bollinger_bands(prices: pd.Series, period: int = 20) -> Dict:
    """Calculate Bollinger Bands"""
    sma = prices.rolling(window=period).mean()
    std = prices.rolling(window=period).std()
    upper = sma + (std * 2)
    lower = sma - (std * 2)

    current_price = prices.iloc[-1]
    band_width = ((upper.iloc[-1] - lower.iloc[-1]) / sma.iloc[-1]) * 100

    return {
        "upper": float(upper.iloc[-1]),
        "middle": float(sma.iloc[-1]),
        "lower": float(lower.iloc[-1]),
        "band_width": float(band_width),
        "price_position": (current_price - lower.iloc[-1]) / (upper.iloc[-1] - lower.iloc[-1])
    }


def calculate_moving_averages(prices: pd.Series) -> Dict:
    """Calculate multiple moving averages"""
    return {
        "sma_20": float(prices.rolling(window=20).mean().iloc[-1]),
        "sma_50": float(prices.rolling(window=50).mean().iloc[-1]),
        "sma_200": float(prices.rolling(window=200).mean().iloc[-1]),
        "ema_12": float(prices.ewm(span=12, adjust=False).mean().iloc[-1]),
        "ema_26": float(prices.ewm(span=26, adjust=False).mean().iloc[-1])
    }


def calculate_volume_analysis(df: pd.DataFrame) -> Dict:
    """Analyze volume patterns"""
    # Use minimum of 20 or available data length
    window = min(20, len(df))
    avg_volume = df['Volume'].rolling(window=window).mean().iloc[-1]
    current_volume = df['Volume'].iloc[-1]
    volume_ratio = current_volume / avg_volume if avg_volume > 0 and not pd.isna(avg_volume) else 1

    # On-Balance Volume (OBV)
    obv = (df['Volume'] * (~df['Close'].diff().le(0) * 2 - 1)).cumsum()

    # Calculate OBV trend using available data
    if len(obv) >= window:
        obv_trend = (obv.iloc[-1] - obv.iloc[-window]) / obv.iloc[-window] * 100 if obv.iloc[-window] != 0 else 0
    else:
        obv_trend = 0  # Not enough data for trend

    return {
        "current_volume": int(current_volume),
        "avg_volume_20": float(avg_volume) if not pd.isna(avg_volume) else 0.0,
        "volume_ratio": float(volume_ratio),
        "obv_trend": float(obv_trend)
    }


def calculate_momentum_indicators(df: pd.DataFrame) -> Dict:
    """Calculate momentum indicators"""
    # Rate of Change (ROC)
    roc_10 = ((df['Close'].iloc[-1] - df['Close'].iloc[-10]) / df['Close'].iloc[-10]) * 100

    # Stochastic Oscillator
    low_14 = df['Low'].rolling(window=14).min()
    high_14 = df['High'].rolling(window=14).max()
    k_percent = 100 * ((df['Close'] - low_14) / (high_14 - low_14))
    d_percent = k_percent.rolling(window=3).mean()

    # ADX (Average Directional Index) - simplified
    high_diff = df['High'].diff()
    low_diff = -df['Low'].diff()
    plus_dm = high_diff.where((high_diff > low_diff) & (high_diff > 0), 0)
    minus_dm = low_diff.where((low_diff > high_diff) & (low_diff > 0), 0)
    atr = df['High'].subtract(df['Low']).rolling(window=14).mean()
    plus_di = 100 * (plus_dm.rolling(window=14).mean() / atr)
    minus_di = 100 * (minus_dm.rolling(window=14).mean() / atr)
    dx = 100 * abs(plus_di - minus_di) / (plus_di + minus_di)
    adx = dx.rolling(window=14).mean()

    return {
        "roc_10": float(roc_10),
        "stochastic_k": float(k_percent.iloc[-1]),
        "stochastic_d": float(d_percent.iloc[-1]),
        "adx": float(adx.iloc[-1]) if not pd.isna(adx.iloc[-1]) else 25.0
    }


def calculate_technical_score(indicators: Dict, current_price: float) -> Dict:
    """Calculate technical analysis score (0-100) with trend context"""
    signals = []

    # Get trend strength from ADX
    adx = indicators['momentum']['adx']
    is_trending = adx > 25  # Strong trend when ADX > 25
    ma = indicators['moving_averages']

    # RSI Signal with ADX Context (weight: 20%)
    # In strong trends, RSI can stay overbought/oversold longer
    rsi = indicators['rsi']
    if is_trending:
        # In trending markets, adjust RSI thresholds
        if rsi < 30:
            rsi_score = 90  # Still bullish but less extreme
        elif rsi < 40:
            rsi_score = 70
        elif rsi < 60:
            rsi_score = 50
        elif rsi < 70:
            rsi_score = 30
        else:
            # In uptrend, overbought can persist - don't penalize as much
            if current_price > ma['sma_50'] and current_price > ma['sma_200']:
                rsi_score = 40  # Trending up, RSI > 70 is acceptable
            else:
                rsi_score = 10  # Downtrend + overbought = danger
    else:
        # In ranging markets, use traditional RSI thresholds
        if rsi < 30:
            rsi_score = 100  # Oversold - Strong Buy
        elif rsi < 40:
            rsi_score = 75  # Buy
        elif rsi < 60:
            rsi_score = 50  # Neutral
        elif rsi < 70:
            rsi_score = 25  # Sell
        else:
            rsi_score = 0  # Overbought - Strong Sell
    signals.append({"name": "RSI", "score": rsi_score, "weight": 20})

    # MACD Signal with Dynamic Thresholds (weight: 20%)
    # Use volatility-adjusted thresholds instead of fixed 0.5/-0.5
    macd_data = indicators['macd']
    atr = indicators.get('atr', 1.0)  # Get ATR for volatility adjustment

    # Dynamic threshold = 0.1% of current price or ATR-based
    dynamic_threshold = max(current_price * 0.001, atr * 0.1)

    histogram = macd_data['histogram']
    macd_line = macd_data['macd']
    signal_line = macd_data['signal']

    # Score based on MACD position, signal line cross, and histogram strength
    if histogram > 0 and macd_line > signal_line:
        # Bullish: MACD above signal line
        if histogram > dynamic_threshold:
            macd_score = 100  # Strong bullish momentum
        else:
            macd_score = 75  # Moderate bullish
    elif histogram > 0:
        macd_score = 60  # Weak bullish
    elif histogram < 0 and macd_line < signal_line:
        # Bearish: MACD below signal line
        if histogram < -dynamic_threshold:
            macd_score = 0  # Strong bearish momentum
        else:
            macd_score = 25  # Moderate bearish
    else:
        macd_score = 40  # Weak bearish

    signals.append({"name": "MACD", "score": macd_score, "weight": 20})

    # Bollinger Bands Signal
    bb = indicators['bollinger_bands']
    price_pos = bb['price_position']
    if price_pos < 0.2:
        bb_score = 100  # Near lower band - Buy
    elif price_pos < 0.4:
        bb_score = 75
    elif price_pos < 0.6:
        bb_score = 50
    elif price_pos < 0.8:
        bb_score = 25
    else:
        bb_score = 0  # Near upper band - Sell
    signals.append({"name": "Bollinger Bands", "score": bb_score, "weight": 15})

    # Moving Average Signal
    ma = indicators['moving_averages']
    ma_score = 0
    if current_price > ma['sma_20']:
        ma_score += 25
    if current_price > ma['sma_50']:
        ma_score += 25
    if current_price > ma['sma_200']:
        ma_score += 25
    if ma['sma_20'] > ma['sma_50'] > ma['sma_200']:
        ma_score += 25  # Golden cross pattern
    signals.append({"name": "Moving Averages", "score": ma_score, "weight": 15})

    # Volume Signal
    volume = indicators['volume']
    if volume['volume_ratio'] > 1.5 and volume['obv_trend'] > 0:
        volume_score = 100  # High volume with positive OBV
    elif volume['volume_ratio'] > 1.2:
        volume_score = 75
    elif volume['volume_ratio'] > 0.8:
        volume_score = 50
    else:
        volume_score = 25
    signals.append({"name": "Volume", "score": volume_score, "weight": 10})

    # Momentum Signal
    momentum = indicators['momentum']
    momentum_score = 50
    if momentum['roc_10'] > 5:
        momentum_score = 100
    elif momentum['roc_10'] > 2:
        momentum_score = 75
    elif momentum['roc_10'] < -5:
        momentum_score = 0
    elif momentum['roc_10'] < -2:
        momentum_score = 25

    # Add Stochastic
    if momentum['stochastic_k'] < 20:
        momentum_score = min(100, momentum_score + 20)
    elif momentum['stochastic_k'] > 80:
        momentum_score = max(0, momentum_score - 20)

    signals.append({"name": "Momentum", "score": momentum_score, "weight": 20})

    # Calculate weighted score
    total_weight = sum(s['weight'] for s in signals)
    weighted_score = sum(s['score'] * s['weight'] for s in signals) / total_weight

    return {
        "score": round(weighted_score, 2),
        "signals": signals
    }


def calculate_fundamental_score(info: Dict) -> Dict:
    """Calculate fundamental analysis score (0-100)"""
    signals = []

    # P/E Ratio
    pe = info.get('trailingPE') or info.get('forwardPE')
    if pe:
        if pe < 15:
            pe_score = 100  # Undervalued
        elif pe < 20:
            pe_score = 75
        elif pe < 25:
            pe_score = 50
        elif pe < 30:
            pe_score = 25
        else:
            pe_score = 0  # Overvalued
        signals.append({"name": "P/E Ratio", "score": pe_score, "weight": 25})

    # P/B Ratio
    pb = info.get('priceToBook')
    if pb:
        if pb < 1:
            pb_score = 100
        elif pb < 2:
            pb_score = 75
        elif pb < 3:
            pb_score = 50
        else:
            pb_score = 25
        signals.append({"name": "P/B Ratio", "score": pb_score, "weight": 15})

    # ROE
    roe = info.get('returnOnEquity')
    if roe:
        roe_percent = roe * 100
        if roe_percent > 20:
            roe_score = 100
        elif roe_percent > 15:
            roe_score = 75
        elif roe_percent > 10:
            roe_score = 50
        else:
            roe_score = 25
        signals.append({"name": "ROE", "score": roe_score, "weight": 20})

    # Debt to Equity
    debt_to_equity = info.get('debtToEquity')
    if debt_to_equity:
        if debt_to_equity < 50:
            debt_score = 100
        elif debt_to_equity < 100:
            debt_score = 75
        elif debt_to_equity < 150:
            debt_score = 50
        else:
            debt_score = 25
        signals.append({"name": "Debt/Equity", "score": debt_score, "weight": 20})

    # Profit Margin
    profit_margin = info.get('profitMargins')
    if profit_margin:
        margin_percent = profit_margin * 100
        if margin_percent > 20:
            margin_score = 100
        elif margin_percent > 15:
            margin_score = 75
        elif margin_percent > 10:
            margin_score = 50
        else:
            margin_score = 25
        signals.append({"name": "Profit Margin", "score": margin_score, "weight": 20})

    if not signals:
        return {"score": 50, "signals": []}

    total_weight = sum(s['weight'] for s in signals)
    weighted_score = sum(s['score'] * s['weight'] for s in signals) / total_weight

    return {
        "score": round(weighted_score, 2),
        "signals": signals
    }


def get_overall_signal(technical_score: float, fundamental_score: float, sentiment_score: float) -> Dict:
    """
    Calculate overall signal with weighted scoring
    Technical: 50%, Fundamental: 30%, Sentiment: 20%
    """
    overall_score = (technical_score * 0.5) + (fundamental_score * 0.3) + (sentiment_score * 0.2)

    # Determine signal
    if overall_score >= 75:
        signal = "STRONG BUY"
        color = "darkgreen"
        confidence = "High"
    elif overall_score >= 60:
        signal = "BUY"
        color = "green"
        confidence = "Medium-High"
    elif overall_score >= 40:
        signal = "NEUTRAL"
        color = "gray"
        confidence = "Medium"
    elif overall_score >= 25:
        signal = "SELL"
        color = "orange"
        confidence = "Medium-High"
    else:
        signal = "STRONG SELL"
        color = "darkred"
        confidence = "High"

    return {
        "signal": signal,
        "score": round(overall_score, 2),
        "color": color,
        "confidence": confidence
    }


def get_timeframe_signals(ticker: str, df: pd.DataFrame, info: Dict) -> Dict:
    """Generate signals for different timeframes"""

    # Intraday (Short-term): Last 5 days, focus on quick moves with volume
    intraday_df = df.tail(5)
    if len(intraday_df) >= 5:
        intraday_rsi = calculate_rsi(intraday_df['Close'], period=5)
        intraday_macd = calculate_macd(intraday_df['Close'])
        intraday_volume = calculate_volume_analysis(intraday_df)
        intraday_score = 50

        # RSI signal for quick moves
        if intraday_rsi < 30:
            intraday_score += 20
        elif intraday_rsi > 70:
            intraday_score -= 20

        # MACD for momentum
        if intraday_macd['histogram'] > 0:
            intraday_score += 20
        else:
            intraday_score -= 20

        # Volume confirmation - critical for intraday
        if intraday_volume['volume_ratio'] > 1.3:
            intraday_score += 10  # High volume confirms move
        elif intraday_volume['volume_ratio'] < 0.7:
            intraday_score -= 10  # Low volume = weak move

        intraday_signal = "BUY" if intraday_score >= 60 else "SELL" if intraday_score <= 40 else "NEUTRAL"
    else:
        intraday_signal = "INSUFFICIENT DATA"
        intraday_score = 50

    # Swing (Medium-term): Last 50 days with multi-indicator confluence
    swing_df = df.tail(50)
    if len(swing_df) >= 20:
        swing_rsi = calculate_rsi(swing_df['Close'], period=14)
        swing_macd = calculate_macd(swing_df['Close'])
        swing_ma = calculate_moving_averages(swing_df['Close'])
        swing_volume = calculate_volume_analysis(swing_df)
        swing_momentum = calculate_momentum_indicators(swing_df)
        current_price = swing_df['Close'].iloc[-1]

        swing_score = 50
        confirmations = 0  # Track number of bullish confirmations

        # 1. Trend confirmation (Moving Averages) - 25 points
        if current_price > swing_ma['sma_20'] and current_price > swing_ma['sma_50']:
            swing_score += 25
            confirmations += 1
        elif current_price < swing_ma['sma_20'] and current_price < swing_ma['sma_50']:
            swing_score -= 25
            confirmations -= 1

        # Check for golden/death cross
        if swing_ma['sma_20'] > swing_ma['sma_50']:
            swing_score += 5
        else:
            swing_score -= 5

        # 2. Momentum confirmation (RSI + MACD) - 25 points
        # RSI with trend context from ADX
        adx = swing_momentum['adx']
        if adx > 25:  # Strong trend
            # In trends, RSI extremes are less reliable
            if 40 < swing_rsi < 70:
                swing_score += 10
                confirmations += 0.5
            elif swing_rsi <= 40:
                swing_score += 15
                confirmations += 1
            elif swing_rsi >= 70:
                swing_score -= 10
        else:  # Ranging market
            if swing_rsi < 40:
                swing_score += 15
                confirmations += 1
            elif swing_rsi > 60:
                swing_score -= 15
                confirmations -= 1

        # MACD confirmation
        if swing_macd['histogram'] > 0 and swing_macd['macd'] > swing_macd['signal']:
            swing_score += 10
            confirmations += 0.5
        elif swing_macd['histogram'] < 0 and swing_macd['macd'] < swing_macd['signal']:
            swing_score -= 10
            confirmations -= 0.5

        # 3. Volume confirmation - 15 points (critical for breakouts)
        if swing_volume['volume_ratio'] > 1.2 and swing_volume['obv_trend'] > 0:
            swing_score += 15
            confirmations += 1
        elif swing_volume['volume_ratio'] < 0.8:
            swing_score -= 10
            confirmations -= 0.5

        # 4. Additional momentum from Stochastic - 10 points
        if swing_momentum['stochastic_k'] < 30:
            swing_score += 10
        elif swing_momentum['stochastic_k'] > 70:
            swing_score -= 10

        # Require at least 2 confirmations for strong signal
        # This reduces false signals significantly
        if confirmations >= 2:
            swing_signal = "BUY" if swing_score >= 60 else "NEUTRAL"
        elif confirmations <= -2:
            swing_signal = "SELL" if swing_score <= 40 else "NEUTRAL"
        else:
            swing_signal = "NEUTRAL"  # Not enough confluence

    else:
        swing_signal = "INSUFFICIENT DATA"
        swing_score = 50

    # Long-term: Full dataset with trend confirmation
    if len(df) >= 200:
        long_rsi = calculate_rsi(df['Close'], period=14)
        long_ma = calculate_moving_averages(df['Close'])
        long_volume = calculate_volume_analysis(df)
        current_price = df['Close'].iloc[-1]

        long_score = 50

        # Golden cross / Death cross (strongest signal for long-term)
        if long_ma['sma_50'] > long_ma['sma_200']:
            long_score += 25
        else:
            long_score -= 25

        # Price above/below 200-day MA (key long-term indicator)
        if current_price > long_ma['sma_200']:
            long_score += 20
        else:
            long_score -= 20

        # Volume trend confirmation
        if long_volume['obv_trend'] > 0:
            long_score += 5
        else:
            long_score -= 5

        long_signal = "BUY" if long_score >= 60 else "SELL" if long_score <= 40 else "NEUTRAL"
    else:
        long_signal = "NEUTRAL"
        long_score = 50

    return {
        "intraday": {
            "timeframe": "1-3 Days",
            "signal": intraday_signal,
            "score": round(intraday_score, 2),
            "description": "Short-term scalping and day trading"
        },
        "swing": {
            "timeframe": "1-4 Weeks",
            "signal": swing_signal,
            "score": round(swing_score, 2),
            "description": "Medium-term swing trading"
        },
        "long_term": {
            "timeframe": "3-12 Months",
            "signal": long_signal,
            "score": round(long_score, 2),
            "description": "Long-term position trading"
        }
    }


def analyze_trading_signals(ticker: str) -> Dict:
    """
    Comprehensive trading signal analysis
    Returns detailed signals with multiple timeframes
    """
    try:
        stock = yf.Ticker(ticker)
        info = stock.info

        # Get historical data (1 year for comprehensive analysis)
        df = stock.history(period="1y")

        if df.empty or len(df) < 20:
            return {
                "error": "Insufficient data for analysis",
                "ticker": ticker
            }

        current_price = df['Close'].iloc[-1]

        # Calculate all indicators
        indicators = {
            "rsi": calculate_rsi(df['Close']),
            "macd": calculate_macd(df['Close']),
            "bollinger_bands": calculate_bollinger_bands(df['Close']),
            "moving_averages": calculate_moving_averages(df['Close']),
            "volume": calculate_volume_analysis(df),
            "momentum": calculate_momentum_indicators(df),
            "atr": calculate_atr(df)  # Add ATR for volatility-adjusted thresholds
        }

        # Calculate scores
        technical_analysis = calculate_technical_score(indicators, current_price)
        fundamental_analysis = calculate_fundamental_score(info)

        # Sentiment score (placeholder - would integrate with news API)
        sentiment_score = 50  # Neutral default

        # Overall signal
        overall = get_overall_signal(
            technical_analysis['score'],
            fundamental_analysis['score'],
            sentiment_score
        )

        # Timeframe-specific signals
        timeframe_signals = get_timeframe_signals(ticker, df, info)

        return {
            "ticker": ticker,
            "current_price": float(current_price),
            "timestamp": datetime.now().isoformat(),
            "overall_signal": overall,
            "technical_analysis": technical_analysis,
            "fundamental_analysis": fundamental_analysis,
            "sentiment_score": sentiment_score,
            "timeframe_signals": timeframe_signals,
            "key_indicators": {
                "rsi": round(indicators['rsi'], 2),
                "macd_histogram": round(indicators['macd']['histogram'], 4),
                "price_vs_sma50": "Above" if current_price > indicators['moving_averages']['sma_50'] else "Below",
                "price_vs_sma200": "Above" if current_price > indicators['moving_averages']['sma_200'] else "Below",
                "volume_ratio": round(indicators['volume']['volume_ratio'], 2),
                "adx": round(indicators['momentum']['adx'], 2)
            }
        }

    except Exception as e:
        return {
            "error": f"Error analyzing signals: {str(e)}",
            "ticker": ticker
        }
